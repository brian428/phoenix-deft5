/*!
DeftJS 5.0.0

Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2014 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* A collection of useful static methods for interacting with Functions.
*/

Ext.define('Deft.util.Function', {
  alternateClassName: ['Deft.Function'],
  statics: {
    /**
    		* Returns a new wrapper function that caches the return value for previously processed function argument(s).
    		* 
    		* @param {Function} fn Function to wrap.
    		* @param {Object} scope Optional scope in which to execute the wrapped function.
    		* @param {Function} hashFn Optional function used to compute a hash key for storing the result, based on the arguments to the original function.
    		* @return {Function} The new wrapper function.
    */

    memoize: function(fn, scope, hashFn) {
      var memo;
      memo = {};
      return function(value) {
        var key;
        key = Deft.isFunction(hashFn) ? hashFn.apply(scope, arguments) : value;
        if (!(key in memo)) {
          memo[key] = fn.apply(scope, arguments);
        }
        return memo[key];
      };
    },
    /**
    		* @method
    		* Schedules the specified callback function to be executed on the next turn of the event loop.
    		* 
    		* @param {Function} fn Callback function.
    		* @param {Object} scope Optional scope for the callback.
          * @param {Mixed[]} parameters Optional callback parameters.
    */

    nextTick: Ext.emptyFn,
    /**
    		* @method
    		* Evalutes whether the specified value is a Function.
    		* Also available as Deft.isFunction().
    		* **NOTE:** Ext JS 4.2.0 and 4.2.1 shipped with a broken version of Ext.isFunction.
    		* @param {Mixed} value Value to evaluate.
    		* @return {Boolean}
    */

    isFunction: Ext.emptyFn,
    /**
    		* Creates a new wrapper function that spreads the passed Array over the target function arguments.
    		* 
    		* @param {Function} fn Function to wrap.
    		* @param {Object} scope Optional scope in which to execute the wrapped function.
    		* @return {Function} The new wrapper function.
    */

    spread: function(fn, scope) {
      return function(array) {
        if (!Ext.isArray(array)) {
          Ext.Error.raise({
            msg: "Error spreading passed Array over target function arguments: passed a non-Array."
          });
        }
        return fn.apply(scope, array);
      };
    }
  }
}, function() {
  if (typeof setImmediate !== "undefined" && setImmediate !== null) {
    this.nextTick = function(fn, scope, parameters) {
      if ((scope != null) || (parameters != null)) {
        fn = Ext.Function.bind(fn, scope, parameters);
      }
      setImmediate(fn);
    };
  } else {
    this.nextTick = function(fn, scope, parameters) {
      if ((scope != null) || (parameters != null)) {
        fn = Ext.Function.bind(fn, scope, parameters);
      }
      setTimeout(fn, 0);
    };
  }
  if (typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function') {
    this.isFunction = function(value) {
      return !!value && toString.call(value) === '[object Function]';
    };
  } else {
    this.isFunction = function(value) {
      return !!value && typeof value === 'function';
    };
  }
  Deft.isFunction = this.isFunction;
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* Logger used by DeftJS.
*
* Output is displayed in the console when using `ext-dev`/`ext-all-dev` or `sencha-debug`/`sencha-all-debug`.
*
* @private
*/

Ext.define('Deft.log.Logger', {
  alternateClassName: ['Deft.Logger'],
  requires: ['Deft.util.Function'],
  singleton: true,
  /**
  	* Logs a message with the specified priority.
  	*
  	* @param {String} message The message to log.
  	* @param {String} priority The priority of the log message. Valid values are: `verbose`, `info`, `deprecate`, `warn` and `error`.
  */

  log: function(message, priority) {
    if (priority == null) {
      priority = 'info';
    }
  },
  /**
  	* Logs a message with 'verbose' priority.
  	*
  	* @param {String} message The message to log.
  */

  verbose: function(message) {
    this.log(message, 'verbose');
  },
  /**
  	* Logs a message with 'info' priority.
  	*
  	* @param {String} message The message to log.
  */

  info: function(message) {
    this.log(message, 'info');
  },
  /**
  	* Logs a message with 'deprecate' priority.
  	*
  	* @param {String} message The message to log.
  */

  deprecate: function(message) {
    this.log(message, 'deprecate');
  },
  /**
  	* Logs a message with 'warn' priority.
  	*
  	* @param {String} message The message to log.
  */

  warn: function(message) {
    this.log(message, 'warn');
  },
  /**
  	* Logs a message with 'error' priority.
  	*
  	* @param {String} message The message to log.
  */

  error: function(message) {
    this.log(message, 'error');
  }
}, function() {
  return this.log = function(message, priority) {
    if (priority == null) {
      priority = 'info';
    }
    if (priority === 'verbose') {
      priority = 'info';
    }
    if (priority === 'deprecate') {
      priority = 'warn';
    }
    Ext.Logger.log(message, priority);
  };
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* Used by Deft.ioc.Injector.
* @private
*/

Ext.define('Deft.ioc.DependencyProvider', {
  requires: ['Deft.log.Logger'],
  config: {
    identifier: null,
    /**
    		Class to be instantiated, by either full name, alias or alternate name, to resolve this dependency.
    */

    className: null,
    /**
    		Optional arguments to pass to the class' constructor when instantiating a class to resolve this dependency.
    */

    parameters: null,
    /**
    		Factory function to be executed to obtain the corresponding object instance or value to resolve this dependency.
    
    		NOTE: For lazily instantiated dependencies, this function will be passed the object instance for which the dependency is being resolved.
    */

    fn: null,
    /**
    		Value to use to resolve this dependency.
    */

    value: void 0,
    /**
    		Indicates whether this dependency should be resolved as a singleton, or as a transient value for each resolution request.
    */

    singleton: true,
    /**
    		Indicates whether this dependency should be 'eagerly' instantiated when this provider is defined, rather than 'lazily' instantiated when later requested.
    
    		NOTE: Only valid when either a factory function or class is specified as a singleton.
    */

    eager: false
  },
  constructor: function(config) {
    var classDefinition;
    this.initConfig(config);
    if ((config.value != null) && config.value.constructor === Object) {
      this.setValue(config.value);
    }
    if (this.getEager()) {
      if (this.getValue() != null) {
        Ext.Error.raise({
          msg: "Error while configuring '" + (this.getIdentifier()) + "': a 'value' cannot be created eagerly."
        });
      }
      if (!this.getSingleton()) {
        Ext.Error.raise({
          msg: "Error while configuring '" + (this.getIdentifier()) + "': only singletons can be created eagerly."
        });
      }
    }
    if (this.getClassName() != null) {
      classDefinition = Ext.ClassManager.get(this.getClassName());
      if (classDefinition == null) {
        Deft.Logger.warn("Synchronously loading '" + (this.getClassName()) + "'; consider adding Ext.require('" + (this.getClassName()) + "') above Ext.onReady.");
        Ext.syncRequire(this.getClassName());
        classDefinition = Ext.ClassManager.get(this.getClassName());
      }
      if (classDefinition == null) {
        Ext.Error.raise({
          msg: "Error while configuring rule for '" + (this.getIdentifier()) + "': unrecognized class name or alias: '" + (this.getClassName()) + "'"
        });
      }
    }
    if (!this.getSingleton()) {
      if (this.getClassName() != null) {
        if (Ext.ClassManager.get(this.getClassName()).singleton) {
          Ext.Error.raise({
            msg: "Error while configuring rule for '" + (this.getIdentifier()) + "': singleton classes cannot be configured for injection as a prototype. Consider removing 'singleton: true' from the class definition."
          });
        }
      }
      if (this.getValue() != null) {
        Ext.Error.raise({
          msg: "Error while configuring '" + (this.getIdentifier()) + "': a 'value' can only be configured as a singleton."
        });
      }
    } else {
      if ((this.getClassName() != null) && (this.getParameters() != null)) {
        if (Ext.ClassManager.get(this.getClassName()).singleton) {
          Ext.Error.raise({
            msg: "Error while configuring rule for '" + (this.getIdentifier()) + "': parameters cannot be applied to singleton classes. Consider removing 'singleton: true' from the class definition."
          });
        }
      }
    }
    return this;
  },
  /**
  	Resolve a target instance's dependency with an object instance or value generated by this dependency provider.
  */

  resolve: function(targetInstance, targetInstanceConstructorArguments) {
    var fnArguments, instance, parameters;
    Deft.Logger.log("Resolving '" + (this.getIdentifier()) + "'.");
    if (this.getValue() !== void 0) {
      return this.getValue();
    }
    instance = null;
    if (this.getFn() != null) {
      Deft.Logger.log("Executing factory function.");
      if (targetInstanceConstructorArguments) {
        fnArguments = [targetInstance].concat(Ext.toArray(targetInstanceConstructorArguments));
      } else {
        fnArguments = [targetInstance];
      }
      instance = this.getFn().apply(Deft.Injector, fnArguments);
    } else if (this.getClassName() != null) {
      if (Ext.ClassManager.get(this.getClassName()).singleton) {
        Deft.Logger.log("Using existing singleton instance of '" + (this.getClassName()) + "'.");
        instance = Ext.ClassManager.get(this.getClassName());
      } else {
        Deft.Logger.log("Creating instance of '" + (this.getClassName()) + "'.");
        parameters = this.getParameters() != null ? [this.getClassName()].concat(this.getParameters()) : [this.getClassName()];
        instance = Ext.create.apply(this, parameters);
      }
    } else {
      Ext.Error.raise({
        msg: "Error while configuring rule for '" + (this.getIdentifier()) + "': no 'value', 'fn', or 'className' was specified."
      });
    }
    if (this.getSingleton()) {
      this.setValue(instance);
    }
    return instance;
  }
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
A lightweight IoC container for dependency injection.

## <u>[Basic Configuration](https://github.com/deftjs/DeftJS/wiki/Basic-Application-and-IoC-Configuration)</u>

    // Common configuration, using dependency provider name and class.
    Deft.Injector.configure({
      companyStore: "DeftQuickStart.store.CompanyStore",
      companyService: "DeftQuickStart.store.CompanyService"
    });

In the IoC configuration above, we have created two **dependency providers**, one named `companyStore` and one named `companyService`. By default, DeftJS uses lazy instantiation to create singleton instances of the `CompanyStore` and `CompanyService` classes. This means that a singleton won't be created until an object in your application specifies one of these dependency providers as an injected dependency.

## <u>[Singleton vs. Prototype Dependency Providers](https://github.com/deftjs/DeftJS/wiki/Singleton-vs.-Prototype-Dependency-Providers)</u>

By default, the dependency providers set up with the DeftJS `Injector` are singletons. This means that only one instance of that dependency will be created, and the same instance will be injected into all objects that request that dependency.

For cases where this is not desired, you can create non-singleton (prototype) dependency providers like this:

    Deft.Injector.configure({
      editHistory: {
        className: "MyApp.util.EditHistory",
        singleton: false
      }
    });

## <u>[Lazy vs. Eager Dependency Creation](https://github.com/deftjs/DeftJS/wiki/Eager-vs.-Lazy-Instantiation)</u>

By default, dependency providers are created **lazily**. This means that the dependency will not be created by DeftJS until another object is created which specifies that dependency as an injection.

In cases where lazy instantiation is not desired, you can set up a dependency provider to be created immediately upon application startup by using the `eager` configuration:

    Deft.Injector.configure({
      notificationService: {
        className: "MyApp.service.NotificationService",
        eager: true
      }
    });

> **NOTE: Only singleton dependency providers can be eagerly instantiated.** This means that specifying `singleton: false` and `eager: true` for a dependency provider won't work. The reason may be obvious: DeftJS can't do anything with a prototype object that is eagerly created, since by definition each injection of a prototype dependency must be a new instance!

## <u>[Constructor Parameters](https://github.com/deftjs/DeftJS/wiki/Constructor-Parameters)</u>

If needed, constructor parameters can be specified for a dependency provider. These parameters will be passed into the constructor of the target object when it is created. Constructor parameters can be configured in the following way:

    Deft.Injector.configure({
      contactStore: {
        className: 'MyApp.store.ContactStore',

        // Specify an array of params to pass into ContactStore constructor
        parameters: [{
          proxy: {
            type: 'ajax',
            url: '/contacts.json',
            reader: {
              type: 'json',
              root: 'contacts'
            }
          }
        }]
      }
    });

## <u>[Factory Functions](https://github.com/deftjs/DeftJS/wiki/Factory-Functions)</u>

A dependency provider can also specify a function to use to create the object that will be injected:

    Deft.Injector.configure({

      contactStore: {
        fn: function() {
          if (useMocks) {
            return Ext.create("MyApp.mock.store.ContactStore");
          } else {
            return Ext.create("MyApp.store.ContactStore");
          }
        },
        eager: true
      },

      contactManager: {
        // The factory function will be passed a single argument:
        // The object instance that the new object will be injected into
        fn: function(instance) {
          if (instance.session.getIsAdmin()) {
            return Ext.create("MyApp.manager.admin.ContactManager");
          } else {
            return Ext.create("MyApp.manager.user.ContactManager");
          }
        },
        singleton: false
      }

    });

When the Injector is called to resolve dependencies for these identifiers, the factory function is called and the dependency is resolved with the return value.

As shown above, a lazily instantiated factory function can optionally accept a parameter, corresponding to the instance for which the Injector is currently injecting dependencies.

Factory function dependency providers can be configured as singletons or prototypes and can be eagerly or lazily instantiated.

> **NOTE: Only singleton factory functions can be eagerly instantiated.** This means that specifying `singleton: false` and `eager: true` for a dependency provider won't work. The reason may be obvious: DeftJS can't do anything with a prototype object that is eagerly created, since by definition each injection of a prototype dependency must be a new instance!
*/

Ext.define('Deft.ioc.Injector', {
  alternateClassName: ['Deft.Injector'],
  requires: ['Ext.Component', 'Deft.log.Logger', 'Deft.ioc.DependencyProvider', 'Deft.util.Function'],
  singleton: true,
  constructor: function() {
    this.providers = {};
    this.injectionStack = [];
    return this;
  },
  /**
  	Configure the Injector.
  */

  configure: function(configuration) {
    var newProviders;
    Deft.Logger.log('Configuring the injector.');
    newProviders = {};
    Ext.Object.each(configuration, function(identifier, config) {
      var provider;
      Deft.Logger.log("Configuring dependency provider for '" + identifier + "'.");
      if (Ext.isString(config)) {
        provider = Ext.create('Deft.ioc.DependencyProvider', {
          identifier: identifier,
          className: config
        });
      } else {
        provider = Ext.create('Deft.ioc.DependencyProvider', Ext.apply({
          identifier: identifier
        }, config));
      }
      this.providers[identifier] = provider;
      newProviders[identifier] = provider;
    }, this);
    Ext.Object.each(newProviders, function(identifier, provider) {
      if (provider.getEager()) {
        Deft.Logger.log("Eagerly creating '" + (provider.getIdentifier()) + "'.");
        provider.resolve();
      }
    }, this);
  },
  /**
  	Reset the Injector.
  */

  reset: function() {
    Deft.Logger.log('Resetting the injector.');
    this.providers = {};
  },
  /**
  	Indicates whether the Injector can resolve a dependency by the specified identifier with the corresponding object instance or value.
  */

  canResolve: function(identifier) {
    var provider;
    provider = this.providers[identifier];
    return provider != null;
  },
  /**
  	Resolve a dependency (by identifier) with the corresponding object instance or value.
  
  	Optionally, the caller may specify the target instance (to be supplied to the dependency provider's factory function, if applicable).
  */

  resolve: function(identifier, targetInstance, targetInstanceConstructorArguments) {
    var provider;
    provider = this.providers[identifier];
    if (provider != null) {
      return provider.resolve(targetInstance, targetInstanceConstructorArguments);
    } else {
      Ext.Error.raise({
        msg: "Error while resolving value to inject: no dependency provider found for '" + identifier + "'."
      });
    }
  },
  /**
  	Inject dependencies (by their identifiers) into the target object instance.
  */

  inject: function(identifiers, targetInstance, targetInstanceConstructorArguments, targetInstanceIsInitialized) {
    var injectConfig, name, originalInitConfigFunction, setterFunctionName, stackMessage, targetClass, value;
    if (targetInstanceIsInitialized == null) {
      targetInstanceIsInitialized = true;
    }
    targetClass = Ext.getClassName(targetInstance);
    if (Ext.Array.contains(this.injectionStack, targetClass)) {
      stackMessage = this.injectionStack.join(" -> ");
      this.injectionStack = [];
      Ext.Error.raise({
        msg: "Error resolving dependencies for '" + targetClass + "'. A circular dependency exists in its injections: " + stackMessage + " -> *" + targetClass + "*"
      });
      return null;
    }
    this.injectionStack.push(targetClass);
    injectConfig = {};
    if (Ext.isString(identifiers)) {
      identifiers = [identifiers];
    }
    Ext.Object.each(identifiers, function(key, value) {
      var identifier, resolvedValue, targetProperty;
      targetProperty = Ext.isArray(identifiers) ? value : key;
      identifier = value;
      resolvedValue = this.resolve(identifier, targetInstance, targetInstanceConstructorArguments);
      if (targetProperty in targetInstance.config) {
        Deft.Logger.log("Injecting '" + identifier + "' into '" + targetClass + "." + targetProperty + "' config.");
        injectConfig[targetProperty] = resolvedValue;
      } else {
        Deft.Logger.log("Injecting '" + identifier + "' into '" + targetClass + "." + targetProperty + "' property.");
        targetInstance[targetProperty] = resolvedValue;
      }
    }, this);
    this.injectionStack = [];
    if (targetInstanceIsInitialized) {
      for (name in injectConfig) {
        value = injectConfig[name];
        setterFunctionName = 'set' + Ext.String.capitalize(name);
        targetInstance[setterFunctionName].call(targetInstance, value);
      }
    } else if (Deft.isFunction(targetInstance.initConfig)) {
      originalInitConfigFunction = targetInstance.initConfig;
      targetInstance.initConfig = function(config) {
        var result;
        result = originalInitConfigFunction.call(this, Ext.Object.merge({}, config || {}, injectConfig));
        return result;
      };
    }
    return targetInstance;
  }
}, function() {
  Ext.define('Deft.InjectableComponent', {
    override: 'Ext.Component',
    constructor: function(config) {
      config = Ext.Object.merge({}, config || {}, this.injectConfig || {});
      delete this.injectConfig;
      return this.callParent([config]);
    }
  });
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* A collection of useful static methods for interacting with (and normalizing differences between) the Sencha Touch and Ext JS class systems.
* @private
*/

Ext.define('Deft.core.Class', {
  alternateClassName: ['Deft.Class'],
  statics: {
    /**
    		* Determines whether the passed Class reference is or extends the specified Class (by name).
    		*
    		* @return {Boolean} A Boolean indicating whether the specified Class reference is or extends the specified Class (by name)
    */

    extendsClass: function(targetClass, className) {
      var error;
      try {
        if (Ext.getClassName(targetClass) === className) {
          return true;
        }
        if (targetClass != null ? targetClass.superclass : void 0) {
          if (Ext.getClassName(targetClass.superclass) === className) {
            return true;
          } else {
            return Deft.Class.extendsClass(Ext.getClass(targetClass.superclass), className);
          }
        } else {
          return false;
        }
      } catch (_error) {
        error = _error;
        return false;
      }
    }
  }
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* Event listener for events fired via the Deft.event.LiveEventBus.
* @private
*/

Ext.define('Deft.event.LiveEventListener', {
  alternateClassName: ['Deft.LiveEventListener'],
  requires: ['Ext.ComponentQuery'],
  constructor: function(config) {
    var component, components, _i, _len;
    Ext.apply(this, config);
    this.components = [];
    components = Ext.ComponentQuery.query(this.selector, this.container);
    for (_i = 0, _len = components.length; _i < _len; _i++) {
      component = components[_i];
      this.components.push(component);
      component.on(this.eventName, this.fn, this.scope, this.options);
    }
  },
  destroy: function() {
    var component, _i, _len, _ref;
    _ref = this.components;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      component = _ref[_i];
      component.un(this.eventName, this.fn, this.scope);
    }
    this.components = null;
  },
  register: function(component) {
    if (this.matches(component)) {
      this.components.push(component);
      component.on(this.eventName, this.fn, this.scope, this.options);
    }
  },
  unregister: function(component) {
    var index;
    index = Ext.Array.indexOf(this.components, component);
    if (index !== -1) {
      component.un(this.eventName, this.fn, this.scope);
      Ext.Array.erase(this.components, index, 1);
    }
  },
  matches: function(component) {
    if (this.selector === null && this.container === component) {
      return true;
    }
    if (this.container === null && Ext.Array.contains(Ext.ComponentQuery.query(this.selector), component)) {
      return true;
    }
    if (component.isDescendantOf(this.container) && Ext.Array.contains(this.container.query(this.selector), component)) {
      return true;
    }
    return false;
  }
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* Event bus for live component selectors.
* @private
*/

Ext.define('Deft.event.LiveEventBus', {
  alternateClassName: ['Deft.LiveEventBus'],
  requires: ['Ext.Component', 'Ext.ComponentManager', 'Deft.event.LiveEventListener'],
  singleton: true,
  constructor: function() {
    this.listeners = [];
  },
  destroy: function() {
    var listener, _i, _len, _ref;
    _ref = this.listeners;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listener = _ref[_i];
      listener.destroy();
    }
    this.listeners = null;
  },
  addListener: function(container, selector, eventName, fn, scope, options) {
    var listener;
    listener = Ext.create('Deft.event.LiveEventListener', {
      container: container,
      selector: selector,
      eventName: eventName,
      fn: fn,
      scope: scope,
      options: options
    });
    this.listeners.push(listener);
  },
  removeListener: function(container, selector, eventName, fn, scope) {
    var listener;
    listener = this.findListener(container, selector, eventName, fn, scope);
    if (listener != null) {
      Ext.Array.remove(this.listeners, listener);
      listener.destroy();
    }
  },
  on: function(container, selector, eventName, fn, scope, options) {
    return this.addListener(container, selector, eventName, fn, scope, options);
  },
  un: function(container, selector, eventName, fn, scope) {
    return this.removeListener(container, selector, eventName, fn, scope);
  },
  findListener: function(container, selector, eventName, fn, scope) {
    var listener, _i, _len, _ref;
    _ref = this.listeners;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listener = _ref[_i];
      if (listener.container === container && listener.selector === selector && listener.eventName === eventName && listener.fn === fn && listener.scope === scope) {
        return listener;
      }
    }
    return null;
  },
  register: function(component) {
    component.on('added', this.onComponentAdded, this);
    component.on('removed', this.onComponentRemoved, this);
  },
  unregister: function(component) {
    component.un('added', this.onComponentAdded, this);
    component.un('removed', this.onComponentRemoved, this);
  },
  onComponentAdded: function(component, container, eOpts) {
    var listener, _i, _len, _ref;
    _ref = this.listeners;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listener = _ref[_i];
      listener.register(component);
    }
  },
  onComponentRemoved: function(component, container, eOpts) {
    var listener, _i, _len, _ref;
    _ref = this.listeners;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listener = _ref[_i];
      listener.unregister(component);
    }
  }
}, function() {
  Ext.Function.interceptAfter(Ext.ComponentManager, 'register', function(component) {
    Deft.event.LiveEventBus.register(component);
  });
  Ext.Function.interceptAfter(Ext.ComponentManager, 'unregister', function(component) {
    Deft.event.LiveEventBus.unregister(component);
  });
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* A mixin that marks a class as participating in dependency injection. Used in conjunction with Deft.ioc.Injector.
*/

Ext.define('Deft.mixin.Injectable', {
  extend: 'Ext.Mixin',
  requires: ['Deft.core.Class', 'Deft.ioc.Injector', 'Deft.log.Logger'],
  mixinConfig: {
    before: {
      constructor: 'onCreate'
    }
  },
  isInjectable: true,
  mixinId: 'injectable',
  onCreate: function() {
    var objectifyInject;
    objectifyInject = function(Class) {
      var id, inject, injectBase, injectObject, _i, _len;
      if (!Class) {
        return {};
        injectBase = objectifyInject(Class.superclass);
      } else {
        injectBase = {};
      }
      inject = Class.inject || {};
      if (Ext.isString(inject)) {
        inject = [inject];
      }
      if (Ext.isArray(inject)) {
        injectObject = {};
        for (_i = 0, _len = inject.length; _i < _len; _i++) {
          id = inject[_i];
          injectObject[id] = id;
        }
        inject = injectObject;
      }
      return Ext.applyIf(inject, objectifyInject(Class.superclass));
    };
    this.inject = objectifyInject(this);
    if (!this.$injected) {
      Deft.Injector.inject(this.inject, this, arguments, false);
      return this.$injected = true;
    }
  }
});

// Generated by CoffeeScript 1.6.3
/**
* Utility class to support Deft JS mixins.
*/

Ext.define("Deft.util.DeftMixinUtils", {
  statics: {
    /**
    		* Uses the passed mergeFn to recursively merge the specified propertyName up the class hierarchy of the target.
    */

    mergeSuperclassProperty: function(target, propertyName, mergeFn, currentResult) {
      var isRecursionStart, wasMerged;
      if (mergeFn == null) {
        mergeFn = Ext.merge;
      }
      if (currentResult == null) {
        currentResult = null;
      }
      wasMerged = false;
      isRecursionStart = false;
      if (currentResult == null) {
        currentResult = {};
        isRecursionStart = true;
      }
      if (((target != null ? target.superclass : void 0) != null)) {
        currentResult = this.mergeSuperclassProperty(target.superclass, propertyName, mergeFn, currentResult);
      }
      if (((target != null ? target[propertyName] : void 0) != null)) {
        currentResult = mergeFn(currentResult, target[propertyName], Ext.getClassName(target));
        wasMerged = true;
      }
      if (wasMerged && isRecursionStart) {
        target[propertyName] = Ext.clone(currentResult);
      }
      return currentResult;
    },
    /**
    		* Returns the proper method name to call the superclass constructor, based on platform and version.
    */

    parentConstructorForVersion: function() {
      return "callParent";
    }
  }
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* A mixin that marks a class as an observer of events from Observable objects.
* Classes using the mixin should call the mixed-in method 'createObservers()' to
* trigger creation of the event listeners using the 'observe:' configuration.
* The Deft JS ViewController uses this mixin, adding the Observers at construction
* and removing them on ViewController destruction.
*
* **IMPORTANT NOTE:** If you choose to use this mixin in your own classes, and you intend
* to destroy the instance, you **MUST** call the mixed-in method 'removeObservers()' at
* destruction time! Failure to do this will result in memory leaks, since the event
* listeners will not be cleaned up. There is no standard way for this mixin to be notified
* of pending instance destruction, so the developer must ensure that this is done.
*/

Ext.define('Deft.mixin.Observer', {
  requires: ['Deft.log.Logger', 'Deft.util.DeftMixinUtils'],
  /**
  	@private
  */

  onClassMixedIn: function(target) {
    target.override({
      constructor: Deft.mixin.Observer.createMixinInterceptor()
    });
    target.onExtended(function(clazz, config) {
      clazz.override({
        constructor: Deft.mixin.Observer.createMixinInterceptor()
      });
      return true;
    });
  },
  /**
  	* @protected
  */

  createObservers: function() {
    var events, target, _ref;
    this.removeObservers();
    this.registeredObservers = {};
    _ref = this.observe;
    for (target in _ref) {
      events = _ref[target];
      this.addObserver(target, events);
    }
  },
  /**
  	* @protected
  */

  addObserver: function(target, events) {
    var observer;
    observer = Ext.create('Deft.mvc.Observer', {
      host: this,
      target: target,
      events: events
    });
    this.registeredObservers[target] = observer;
  },
  /**
  	* @protected
  */

  removeObservers: function() {
    var observer, target, _ref;
    _ref = this.registeredObservers;
    for (target in _ref) {
      observer = _ref[target];
      observer.destroy();
      delete this.registeredObservers[target];
    }
  },
  statics: {
    MIXIN_COMPLETED_KEY: "$observing",
    PROPERTY_NAME: "observe",
    /**
    		* @private
    */

    createMixinInterceptor: function() {
      return function(config) {
        var mixinCompletedKey, propertyName;
        if (config == null) {
          config = {};
        }
        mixinCompletedKey = Deft.mixin.Observer.MIXIN_COMPLETED_KEY;
        propertyName = Deft.mixin.Observer.PROPERTY_NAME;
        if (this[propertyName] == null) {
          this[propertyName] = {};
        }
        if (!this[mixinCompletedKey] && Ext.Object.getSize(this[propertyName]) > 0) {
          Deft.util.DeftMixinUtils.mergeSuperclassProperty(this, propertyName, Deft.mixin.Observer.propertyMergeHandler);
          Deft.mixin.Observer.afterMixinProcessed(this);
          this[Deft.util.DeftMixinUtils.parentConstructorForVersion()](arguments);
          return this;
        }
        return this[Deft.util.DeftMixinUtils.parentConstructorForVersion()](arguments);
      };
    },
    /**
    		* @private
    		* Called by DeftMixinUtils.mergeSuperclassProperty(). Allows each mixin to define its own
    		* customized subclass/superclass merge logic.
    		*
    		* Merges child and parent observers into a single object. This differs from a normal object merge because
    		* a given observer target and event can potentially have multiple handlers declared in different parent or
    		* child classes. It transforms an event handler value into an array of values, and merges the arrays of handlers
    		* from child to parent. This maintains the handlers even if both parent and child classes have handlers for the
    		* same target and event.
    */

    propertyMergeHandler: function(originalParentObserve, originalChildObserve) {
      var childEvent, childEvents, childHandler, childHandlerArray, childObserve, childTarget, eventOptionNames, parentEvent, parentEvents, parentHandler, parentHandlerArray, parentObserve, parentTarget, _ref, _ref1;
      if (!Ext.isObject(originalParentObserve)) {
        parentObserve = {};
      } else {
        parentObserve = Ext.clone(originalParentObserve);
      }
      if (!Ext.isObject(originalChildObserve)) {
        childObserve = {};
      } else {
        childObserve = Ext.clone(originalChildObserve);
      }
      eventOptionNames = ["buffer", "single", "delay", "element", "target", "destroyable"];
      Deft.mixin.Observer.convertConfigArray(parentObserve, eventOptionNames);
      Deft.mixin.Observer.convertConfigArray(childObserve, eventOptionNames);
      for (childTarget in childObserve) {
        childEvents = childObserve[childTarget];
        for (childEvent in childEvents) {
          childHandler = childEvents[childEvent];
          if (Ext.isString(childHandler)) {
            childObserve[childTarget][childEvent] = childHandler.replace(' ', '').split(',');
          }
          if (!(parentObserve != null ? parentObserve[childTarget] : void 0)) {
            parentObserve[childTarget] = {};
          }
          if (!(parentObserve != null ? (_ref = parentObserve[childTarget]) != null ? _ref[childEvent] : void 0 : void 0)) {
            parentObserve[childTarget][childEvent] = childObserve[childTarget][childEvent];
            delete childObserve[childTarget][childEvent];
          }
        }
      }
      for (parentTarget in parentObserve) {
        parentEvents = parentObserve[parentTarget];
        for (parentEvent in parentEvents) {
          parentHandler = parentEvents[parentEvent];
          if (Ext.isString(parentHandler)) {
            parentObserve[parentTarget][parentEvent] = parentHandler.split(',');
          }
          if (childObserve != null ? (_ref1 = childObserve[parentTarget]) != null ? _ref1[parentEvent] : void 0 : void 0) {
            childHandlerArray = childObserve[parentTarget][parentEvent];
            parentHandlerArray = parentObserve[parentTarget][parentEvent];
            parentObserve[parentTarget][parentEvent] = Ext.Array.unique(Ext.Array.insert(parentHandlerArray, 0, childHandlerArray));
          }
        }
      }
      return parentObserve;
    },
    /**
    		* @private
    		* Converts an observe configuration that use an array of event configuration objects into object keys for
    		* event name, containing an array of configuration objects.
    */

    convertConfigArray: function(observeConfig, eventOptionNames) {
      var handlerConfig, newObserveEvents, observeEvents, observeTarget, thisEventOptionName, thisObserveEvent, _i, _j, _len, _len1, _results;
      _results = [];
      for (observeTarget in observeConfig) {
        observeEvents = observeConfig[observeTarget];
        if (Ext.isArray(observeEvents)) {
          newObserveEvents = {};
          for (_i = 0, _len = observeEvents.length; _i < _len; _i++) {
            thisObserveEvent = observeEvents[_i];
            if (Ext.Object.getSize(thisObserveEvent) === 1) {
              Ext.apply(newObserveEvents, thisObserveEvent);
            } else {
              handlerConfig = {};
              if ((thisObserveEvent != null ? thisObserveEvent.fn : void 0) != null) {
                handlerConfig.fn = thisObserveEvent.fn;
              }
              if ((thisObserveEvent != null ? thisObserveEvent.scope : void 0) != null) {
                handlerConfig.scope = thisObserveEvent.scope;
              }
              for (_j = 0, _len1 = eventOptionNames.length; _j < _len1; _j++) {
                thisEventOptionName = eventOptionNames[_j];
                if ((thisObserveEvent != null ? thisObserveEvent[thisEventOptionName] : void 0) != null) {
                  handlerConfig[thisEventOptionName] = thisObserveEvent[thisEventOptionName];
                }
              }
              newObserveEvents[thisObserveEvent.event] = [handlerConfig];
            }
          }
          _results.push(observeConfig[observeTarget] = newObserveEvents);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    /**
    		@private
    */

    afterMixinProcessed: function(target) {
      target[Deft.mixin.Observer.MIXIN_COMPLETED_KEY] = true;
    }
  }
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* A lightweight Application template class for use with Ext JS.
*/

Ext.define('Deft.mvc.Application', {
  alternateClassName: ['Deft.Application'],
  /**
  	* Indicates whether this Application instance has been initialized.
  */

  initialized: false,
  /**
  	* @param {Object} [config] Configuration object.
  */

  constructor: function(config) {
    if (config == null) {
      config = {};
    }
    this.initConfig(config);
    Ext.onReady(function() {
      this.init();
      this.initialized = true;
    }, this);
    return this;
  },
  /**
  	* Initialize the Application
  */

  init: function() {}
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* Manages live events attached to component selectors. Used by Deft.mvc.ComponentSelector.
* @private
*/

Ext.define('Deft.mvc.ComponentSelectorListener', {
  requires: ['Deft.event.LiveEventBus'],
  constructor: function(config) {
    var component, _i, _len, _ref;
    Ext.apply(this, config);
    if (this.componentSelector.live) {
      Deft.LiveEventBus.addListener(this.componentSelector.view, this.componentSelector.selector, this.eventName, this.fn, this.scope, this.options);
    } else {
      _ref = this.componentSelector.components;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        component = _ref[_i];
        component.on(this.eventName, this.fn, this.scope, this.options);
      }
    }
    return this;
  },
  destroy: function() {
    var component, _i, _len, _ref;
    if (this.componentSelector.live) {
      Deft.LiveEventBus.removeListener(this.componentSelector.view, this.componentSelector.selector, this.eventName, this.fn, this.scope);
    } else {
      _ref = this.componentSelector.components;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        component = _ref[_i];
        component.un(this.eventName, this.fn, this.scope);
      }
    }
  }
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* @private
* Models a component selector used by Deft.mvc.ViewController to locate view components and attach event listeners.
*/

Ext.define('Deft.mvc.ComponentSelector', {
  requires: ['Ext.ComponentQuery', 'Deft.log.Logger', 'Deft.mvc.ComponentSelectorListener', 'Deft.util.Function'],
  constructor: function(config) {
    var eventName, fn, listener, options, scope, _ref;
    Ext.apply(this, config);
    if (!this.live) {
      this.components = this.selector != null ? Ext.ComponentQuery.query(this.selector, this.view) : [this.view];
    }
    this.selectorListeners = [];
    if (Ext.isObject(this.listeners)) {
      _ref = this.listeners;
      for (eventName in _ref) {
        listener = _ref[eventName];
        fn = listener;
        scope = this.scope;
        options = null;
        if (Ext.isObject(listener)) {
          options = Ext.apply({}, listener);
          if (options.fn != null) {
            fn = options.fn;
            delete options.fn;
          }
          if (options.scope != null) {
            scope = options.scope;
            delete options.scope;
          }
        }
        if (Ext.isString(fn) && Deft.isFunction(scope[fn])) {
          fn = scope[fn];
        }
        if (!Deft.isFunction(fn)) {
          Ext.Error.raise({
            msg: "Error adding '" + eventName + "' listener: the specified handler '" + fn + "' is not a Function or does not exist."
          });
        }
        this.addListener(eventName, fn, scope, options);
      }
    }
    return this;
  },
  destroy: function() {
    var selectorListener, _i, _len, _ref;
    _ref = this.selectorListeners;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      selectorListener = _ref[_i];
      selectorListener.destroy();
    }
    this.selectorListeners = [];
  },
  /**
  	Add an event listener to this component selector.
  */

  addListener: function(eventName, fn, scope, options) {
    var selectorListener;
    if (this.findListener(eventName, fn, scope) != null) {
      Ext.Error.raise({
        msg: "Error adding '" + eventName + "' listener: an existing listener for the specified function was already registered for '" + this.selector + "."
      });
    }
    Deft.Logger.log("Adding '" + eventName + "' listener to '" + this.selector + "'.");
    selectorListener = Ext.create('Deft.mvc.ComponentSelectorListener', {
      componentSelector: this,
      eventName: eventName,
      fn: fn,
      scope: scope,
      options: options
    });
    this.selectorListeners.push(selectorListener);
  },
  /**
  	Remove an event listener from this component selector.
  */

  removeListener: function(eventName, fn, scope) {
    var selectorListener;
    selectorListener = this.findListener(eventName, fn, scope);
    if (selectorListener != null) {
      Deft.Logger.log("Removing '" + eventName + "' listener from '" + this.selector + "'.");
      selectorListener.destroy();
      Ext.Array.remove(this.selectorListeners, selectorListener);
    }
  },
  findListener: function(eventName, fn, scope) {
    var selectorListener, _i, _len, _ref;
    _ref = this.selectorListeners;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      selectorListener = _ref[_i];
      if (selectorListener.eventName === eventName && selectorListener.fn === fn && selectorListener.scope === scope) {
        return selectorListener;
      }
    }
    return null;
  }
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* @private
* Used by Deft.mvc.ViewController to handle events fired from injected objects.
*/

Ext.define('Deft.mvc.Observer', {
  requires: ['Deft.core.Class', 'Ext.util.Observable', 'Deft.util.Function'],
  statics: {
    /**
    		* Merges child and parent observers into a single object. This differs from a normal object merge because
    		* a given observer target and event can potentially have multiple handlers declared in different parent or
    		* child classes. It transforms an event handler value into an array of values, and merges the arrays of handlers
    		* from child to parent. This maintains the handlers even if both parent and child classes have handlers for the
    		* same target and event.
    */

    mergeObserve: function(originalParentObserve, originalChildObserve) {
      var childEvent, childEvents, childHandler, childHandlerArray, childObserve, childTarget, convertConfigArray, eventOptionNames, parentEvent, parentEvents, parentHandler, parentHandlerArray, parentObserve, parentTarget, _ref, _ref1;
      if (!Ext.isObject(originalParentObserve)) {
        parentObserve = {};
      } else {
        parentObserve = Ext.clone(originalParentObserve);
      }
      if (!Ext.isObject(originalChildObserve)) {
        childObserve = {};
      } else {
        childObserve = Ext.clone(originalChildObserve);
      }
      eventOptionNames = ["buffer", "single", "delay", "element", "target", "destroyable"];
      convertConfigArray = function(observeConfig) {
        var handlerConfig, newObserveEvents, observeEvents, observeTarget, thisEventOptionName, thisObserveEvent, _i, _j, _len, _len1, _results;
        _results = [];
        for (observeTarget in observeConfig) {
          observeEvents = observeConfig[observeTarget];
          if (Ext.isArray(observeEvents)) {
            newObserveEvents = {};
            for (_i = 0, _len = observeEvents.length; _i < _len; _i++) {
              thisObserveEvent = observeEvents[_i];
              if (Ext.Object.getSize(thisObserveEvent) === 1) {
                Ext.apply(newObserveEvents, thisObserveEvent);
              } else {
                handlerConfig = {};
                if ((thisObserveEvent != null ? thisObserveEvent.fn : void 0) != null) {
                  handlerConfig.fn = thisObserveEvent.fn;
                }
                if ((thisObserveEvent != null ? thisObserveEvent.scope : void 0) != null) {
                  handlerConfig.scope = thisObserveEvent.scope;
                }
                for (_j = 0, _len1 = eventOptionNames.length; _j < _len1; _j++) {
                  thisEventOptionName = eventOptionNames[_j];
                  if ((thisObserveEvent != null ? thisObserveEvent[thisEventOptionName] : void 0) != null) {
                    handlerConfig[thisEventOptionName] = thisObserveEvent[thisEventOptionName];
                  }
                }
                newObserveEvents[thisObserveEvent.event] = [handlerConfig];
              }
            }
            _results.push(observeConfig[observeTarget] = newObserveEvents);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      convertConfigArray(parentObserve);
      convertConfigArray(childObserve);
      for (childTarget in childObserve) {
        childEvents = childObserve[childTarget];
        for (childEvent in childEvents) {
          childHandler = childEvents[childEvent];
          if (Ext.isString(childHandler)) {
            childObserve[childTarget][childEvent] = childHandler.replace(' ', '').split(',');
          }
          if (!(parentObserve != null ? parentObserve[childTarget] : void 0)) {
            parentObserve[childTarget] = {};
          }
          if (!(parentObserve != null ? (_ref = parentObserve[childTarget]) != null ? _ref[childEvent] : void 0 : void 0)) {
            parentObserve[childTarget][childEvent] = childObserve[childTarget][childEvent];
            delete childObserve[childTarget][childEvent];
          }
        }
      }
      for (parentTarget in parentObserve) {
        parentEvents = parentObserve[parentTarget];
        for (parentEvent in parentEvents) {
          parentHandler = parentEvents[parentEvent];
          if (Ext.isString(parentHandler)) {
            parentObserve[parentTarget][parentEvent] = parentHandler.split(',');
          }
          if (childObserve != null ? (_ref1 = childObserve[parentTarget]) != null ? _ref1[parentEvent] : void 0 : void 0) {
            childHandlerArray = childObserve[parentTarget][parentEvent];
            parentHandlerArray = parentObserve[parentTarget][parentEvent];
            parentObserve[parentTarget][parentEvent] = Ext.Array.unique(Ext.Array.insert(parentHandlerArray, 0, childHandlerArray));
          }
        }
      }
      return parentObserve;
    }
  },
  /**
  	* Expects a config object with properties for host, target, and events.
  */

  constructor: function(config) {
    var eventName, events, handler, handlerArray, host, options, references, scope, target, _i, _len;
    this.listeners = [];
    host = config != null ? config.host : void 0;
    target = config != null ? config.target : void 0;
    events = config != null ? config.events : void 0;
    if (host && target && (this.isPropertyChain(target) || this.isTargetObservable(host, target))) {
      for (eventName in events) {
        handlerArray = events[eventName];
        if (Ext.isString(handlerArray)) {
          handlerArray = handlerArray.replace(' ', '').split(',');
        }
        for (_i = 0, _len = handlerArray.length; _i < _len; _i++) {
          handler = handlerArray[_i];
          scope = host;
          options = null;
          if (Ext.isObject(handler)) {
            options = Ext.clone(handler);
            if (options != null ? options.event : void 0) {
              eventName = this.extract(options, "event");
            }
            if (options != null ? options.fn : void 0) {
              handler = this.extract(options, "fn");
            }
            if (options != null ? options.scope : void 0) {
              scope = this.extract(options, "scope");
            }
          }
          references = this.locateReferences(host, target, handler);
          if (references) {
            references.target.on(eventName, references.handler, scope, options);
            this.listeners.push({
              targetName: target,
              target: references.target,
              event: eventName,
              handler: references.handler,
              scope: scope
            });
            Deft.Logger.log("Created observer on '" + target + "' for event '" + eventName + "'.");
          } else {
            Deft.Logger.warn("Could not create observer on '" + target + "' for event '" + eventName + "'.");
          }
        }
      }
    } else {
      Deft.Logger.warn("Could not create observers on '" + target + "' because '" + target + "' is not an Ext.util.Observable");
    }
    return this;
  },
  /**
  	* Returns true if the passed host has a target that is Observable.
  	* Checks for an isObservable=true property, observable mixin, or if the class extends Observable.
  */

  isTargetObservable: function(host, target) {
    var hostTarget, hostTargetClass, _ref;
    hostTarget = this.locateTarget(host, target);
    if (hostTarget == null) {
      return false;
    }
    if ((hostTarget.isObservable != null) || (hostTarget.isUtilObservable != null) || hostTarget.mixinId === "observable" || (((_ref = hostTarget.mixins) != null ? _ref.observable : void 0) != null)) {
      return true;
    } else {
      hostTargetClass = Ext.ClassManager.getClass(hostTarget);
      return Deft.Class.extendsClass(hostTargetClass, 'Ext.util.Observable') || Deft.Class.extendsClass(hostTargetClass, 'Ext.mixin.Observable');
    }
  },
  /**
  	* Attempts to locate an observer target given the host object and target property name.
  	* Checks for both host[ target ], and host.getTarget().
  */

  locateTarget: function(host, target) {
    var result;
    if (Deft.isFunction(host['get' + Ext.String.capitalize(target)])) {
      result = host['get' + Ext.String.capitalize(target)].call(host);
      return result;
    } else if ((host != null ? host["_" + target] : void 0) != null) {
      result = host[target];
      return result;
    } else if ((host != null ? host[target] : void 0) != null) {
      result = host[target];
      return result;
    } else {
      return null;
    }
  },
  /**
  	* Returns true if the passed target is a string containing a '.', indicating that it is referencing a nested property.
  */

  isPropertyChain: function(target) {
    return Ext.isString(target) && target.indexOf('.') > -1;
  },
  /**
  	* Given a host object, target property name, and handler, return object references for the final target and handler function.
  	* If necessary, recurse down a property chain to locate the final target object for the event listener.
  */

  locateReferences: function(host, target, handler) {
    var handlerHost, propertyChain;
    handlerHost = host;
    if (this.isPropertyChain(target)) {
      propertyChain = this.parsePropertyChain(host, target);
      if (!propertyChain) {
        return null;
      }
      host = propertyChain.host;
      target = propertyChain.target;
    }
    if (Deft.isFunction(handler)) {
      return {
        target: this.locateTarget(host, target),
        handler: handler
      };
    } else if (Deft.isFunction(handlerHost[handler])) {
      return {
        target: this.locateTarget(host, target),
        handler: handlerHost[handler]
      };
    } else {
      return null;
    }
  },
  /**
  	* Given a target property chain and a property host object, recurse down the property chain and return
  	* the final host object from the property chain, and the final object that will accept the event listener.
  */

  parsePropertyChain: function(host, target) {
    var propertyChain;
    if (Ext.isString(target)) {
      propertyChain = target.split('.');
    } else if (Ext.isArray(target)) {
      propertyChain = target;
    } else {
      return null;
    }
    if (propertyChain.length > 1 && (this.locateTarget(host, propertyChain[0]) != null)) {
      return this.parsePropertyChain(this.locateTarget(host, propertyChain[0]), propertyChain.slice(1));
    } else if (this.isTargetObservable(host, propertyChain[0])) {
      return {
        host: host,
        target: propertyChain[0]
      };
    } else {
      return null;
    }
  },
  /**
  	* Retrieves the value for the specified object key and removes the pair
  	* from the object.
  */

  extract: function(object, key) {
    var value;
    value = object[key];
    delete object[key];
    return value;
  },
  /**
  	* Iterate through the listeners array and remove each event listener.
  */

  destroy: function() {
    var listenerData, _i, _len, _ref;
    _ref = this.listeners;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listenerData = _ref[_i];
      Deft.Logger.log("Removing observer on '" + listenerData.targetName + "' for event '" + listenerData.event + "'.");
      listenerData.target.un(listenerData.event, listenerData.handler, listenerData.scope);
    }
    this.listeners = [];
  }
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
A lightweight MVC view controller. Full usage instructions in the [DeftJS documentation](https://github.com/deftjs/DeftJS/wiki/ViewController).

First, specify a ViewController to attach to a view:

		Ext.define("DeftQuickStart.view.MyTabPanel", {
			extend: "Ext.tab.Panel",
			controller: "DeftQuickStart.controller.MainController",
			...
		});

Next, define the ViewController:

		Ext.define("DeftQuickStart.controller.MainController", {
			extend: "Deft.mvc.ViewController",

			init: function() {
				return this.callParent(arguments);
			}

		});

## Inject dependencies using the <u>[`inject` property](https://github.com/deftjs/DeftJS/wiki/Injecting-Dependencies)</u>:

		Ext.define("DeftQuickStart.controller.MainController", {
			extend: "Deft.mvc.ViewController",
			inject: ["companyStore"],

			config: {
				companyStore: null
			},

			init: function() {
				return this.callParent(arguments);
			}

		});

## Define <u>[references to view components](https://github.com/deftjs/DeftJS/wiki/Accessing-Views)</u> and <u>[add view listeners](https://github.com/deftjs/DeftJS/wiki/Handling-View-Events)</u> with the `control` property:

		Ext.define("DeftQuickStart.controller.MainController", {
			extend: "Deft.mvc.ViewController",

			control: {

				// Most common configuration, using an itemId and listener
				manufacturingFilter: {
					change: "onFilterChange"
				},

				// Reference only, with no listeners
				serviceIndustryFilter: true,

				// Configuration using selector, listeners, and event listener options
				salesFilter: {
					selector: "toolbar > checkbox",
					listeners: {
						change: {
							fn: "onFilterChange",
							buffer: 50,
							single: true
						}
					}
				}
			},

			init: function() {
				return this.callParent(arguments);
			}

			// Event handlers or other methods here...

		});

## Dynamically monitor view to attach listeners to added components with <u>[live selectors](https://github.com/deftjs/DeftJS/wiki/ViewController-Live-Selectors)</u>:

		control: {
			manufacturingFilter: {
				live: true,
				listeners: {
					change: "onFilterChange"
				}
			}
		};

## Observe events on injected objects with the <u>[`observe` property](https://github.com/deftjs/DeftJS/wiki/ViewController-Observe-Configuration)</u>:

		Ext.define("DeftQuickStart.controller.MainController", {
			extend: "Deft.mvc.ViewController",
			inject: ["companyStore"],

			config: {
				companyStore: null
			},

			observe: {
				// Observe companyStore for the update event
				companyStore: {
					update: "onCompanyStoreUpdateEvent"
				}
			},

			init: function() {
				return this.callParent(arguments);
			},

			onCompanyStoreUpdateEvent: function(store, model, operation, fieldNames) {
				// Do something when store fires update event
			}

		});

## Attach companion view controllers using the <u>[`companions` property](https://github.com/deftjs/DeftJS/wiki/ViewController-Companion-Configuration)</u>:

		Ext.define("DeftQuickStart.controller.MainController", {
			extend: "Deft.mvc.ViewController",
			inject: ["companyStore"],

			config: {
				companyStore: null
			},

			companions: {
				// Create companion view controllers which can also manage the original view
				// This allows a view controller to leverage common behavior provided by other view controllers.
				shoppingCart: "DeftQuickStart.controller.ShoppingCartController"
			},

			init: function() {
				return this.callParent(arguments);
			}

		});
*/

Ext.define('Deft.mvc.ViewController', {
  extend: 'Ext.app.ViewController',
  alternateClassName: ['Deft.ViewController'],
  mixins: ['Deft.mixin.Injectable', 'Deft.mixin.Observer'],
  requires: ['Deft.core.Class', 'Deft.log.Logger', 'Deft.mvc.ComponentSelector', 'Deft.mixin.Injectable', 'Deft.mixin.Observer', 'Deft.mvc.Observer', 'Deft.util.DeftMixinUtils'],
  config: {
    /**
    		* @private
    		* Companion ViewController instances.
    */

    companionInstances: null
  },
  constructor: function(config) {
    if (config == null) {
      config = {};
    }
    if (Ext.isObject(config.companions)) {
      this.companions = Ext.merge(this.companions, config.companions);
      delete config.companions;
    }
    this.callParent(arguments);
    this.createObservers();
    return this;
  },
  /**
  	* @protected
  */

  createCompanions: function() {
    var alias, clazz, _ref, _results;
    this.companionInstances = {};
    _ref = this.companions;
    _results = [];
    for (alias in _ref) {
      clazz = _ref[alias];
      _results.push(this.addCompanion(alias, clazz));
    }
    return _results;
  },
  /**
  	* @protected
  */

  destroyCompanions: function() {
    var alias, instance, _ref, _results;
    _ref = this.companionInstances;
    _results = [];
    for (alias in _ref) {
      instance = _ref[alias];
      _results.push(this.removeCompanion(alias));
    }
    return _results;
  },
  /**
  	* Add a new companion view controller to this view controller.
  	* @param {String} alias The alias for the new companion.
  	* @param {String} class The class name of the companion view controller.
  */

  addCompanion: function(alias, clazz) {
    var error, initialClass, isRecursionStart, newHost, stackMessage;
    if ((this.companionInstances[alias] != null)) {
      Deft.Logger.warn("The specified companion alias '" + alias + "' already exists.");
      return;
    }
    isRecursionStart = false;
    if (Deft.mvc.ViewController.companionCreationStack.length === 0) {
      isRecursionStart = true;
    }
    try {
      if (!Ext.Array.contains(Deft.mvc.ViewController.companionCreationStack, Ext.getClassName(this))) {
        Deft.mvc.ViewController.companionCreationStack.push(Ext.getClassName(this));
      } else {
        Deft.mvc.ViewController.companionCreationStack.push(Ext.getClassName(this));
        initialClass = Deft.mvc.ViewController.companionCreationStack[0];
        stackMessage = Deft.mvc.ViewController.companionCreationStack.join(" -> ");
        Deft.mvc.ViewController.companionCreationStack = [];
        Ext.Error.raise({
          msg: "Error creating companions for '" + initialClass + "'. A circular dependency exists in its companions: " + stackMessage
        });
      }
      newHost = Ext.create(clazz);
      newHost.setView(this.getView());
      this.companionInstances[alias] = newHost;
      if (isRecursionStart) {
        return Deft.mvc.ViewController.companionCreationStack = [];
      }
    } catch (_error) {
      error = _error;
      Deft.Logger.warn("Error initializing associated view controller: an error occurred while creating an instance of the specified controller: '" + clazz + "'.");
      Deft.mvc.ViewController.companionCreationStack = [];
      throw error;
    }
  },
  /**
  	* Removes and destroys a companion view controller from this view controller.
  	* @param {String} alias The alias for the companion host to remove
  */

  removeCompanion: function(alias) {
    var error, _ref;
    if (this.companionInstances[alias] == null) {
      Deft.Logger.warn("The specified companion alias '" + alias + "' cannot be removed because the alias does not exist.");
    }
    try {
      if ((_ref = this.companionInstances[alias]) != null) {
        _ref.destroy();
      }
      return delete this.companionInstances[alias];
    } catch (_error) {
      error = _error;
      Deft.Logger.warn("Error destroying associated view controller: an error occurred while destroying the associated controller with the alias '" + alias + "'.");
      throw error;
    }
  },
  /**
  	* Locates a companion view controller by alias.
  	* @param {String} alias The alias for the desired companion instance
  	* @return {Deft.mvc.ViewController} The companion view controller instance.
  */

  getCompanion: function(alias) {
    return this.companionInstances[alias];
  },
  /**
  	* Destroy the ViewController
  */

  destroy: function() {
    Ext.log("destroy");
    this.callParent(arguments);
    this.removeObservers();
    this.destroyCompanions();
    return true;
  },
  /**
  	* @private
  */

  onViewBeforeDestroy: function() {
    var view;
    view = this.getView();
    if (this.destroy()) {
      view.un('beforedestroy', this.onViewBeforeDestroy, this);
      return true;
    }
    return false;
  },
  /**
  	* Get the component(s) corresponding to the specified view-relative selector.
  */

  getViewComponent: function(selector) {
    var matches;
    if (selector != null) {
      matches = Ext.ComponentQuery.query(selector, this.getView());
      if (matches.length === 0) {
        return null;
      } else if (matches.length === 1) {
        return matches[0];
      } else {
        return matches;
      }
    } else {
      return this.getView();
    }
  },
  onClassExtended: function(clazz, config) {
    clazz.override({
      constructor: Deft.mvc.ViewController.mergeSubclassInterceptor()
    });
    return true;
  },
  privates: {
    setView: function(view) {
      var originalViewDestroyFunction, self;
      this.callParent(arguments);
      if ((Ext.getVersion('extjs') != null)) {
        Ext.log("adding beforedestroy");
        this.getView().on('beforedestroy', this.onViewBeforeDestroy, this);
      } else {
        self = this;
        originalViewDestroyFunction = this.getView().destroy;
        this.getView().destroy = function() {
          if (self.destroy()) {
            originalViewDestroyFunction.call(this);
          }
        };
      }
      this.createCompanions();
    }
  },
  statics: {
    companionCreationStack: [],
    PREPROCESSING_COMPLETED_KEY: "$viewcontroller_processed",
    mergeSubclassInterceptor: function() {
      return function(config) {
        var companionPropertyName;
        if (config == null) {
          config = {};
        }
        companionPropertyName = "companions";
        if (this[companionPropertyName] == null) {
          this[companionPropertyName] = {};
        }
        if (!this[Deft.mvc.ViewController.PREPROCESSING_COMPLETED_KEY]) {
          if (Ext.Object.getSize(this[companionPropertyName]) > 0) {
            Deft.util.DeftMixinUtils.mergeSuperclassProperty(this, companionPropertyName, Deft.mvc.ViewController.companionMergeHandler);
          }
          this[Deft.mvc.ViewController.PREPROCESSING_COMPLETED_KEY] = true;
        }
        this[Deft.util.DeftMixinUtils.parentConstructorForVersion()](arguments);
        return this;
      };
    },
    companionMergeHandler: function(parentCompanions, childCompanions) {
      return Ext.merge(Ext.clone(parentCompanions), Ext.clone(childCompanions));
    }
  }
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2014 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* @private
* Consequences are used internally by a Resolver to capture and notify
* callbacks, and propagate their transformed results as fulfillment or
* rejection.
*
* Developers never directly interact with a Consequence.
*
* A Consequence forms a chain between two Resolvers, where the result of
* the first Resolver is transformed by the corresponding callback before
* being applied to the second Resolver.
*
* Each time a Resolver's then() method is called, it creates a new
* Consequence that will be triggered once its originating Resolver has
* been fulfilled or rejected. A Consequence captures a pair of optional
* onFulfilled and onRejected callbacks.
*
* Each Consequence has its own Resolver (which in turn has a Promise)
* that is resolved or rejected when the Consequence is triggered. When a
* Consequence is triggered by its originating Resolver, it calls the
* corresponding callback and propagates the transformed result to its own
* Resolver; resolved with the callback return value or rejected with any
* error thrown by the callback.
*/

Ext.define('Deft.promise.Consequence', {
  alternateClassName: ['Deft.Consequence'],
  requires: ['Deft.util.Function'],
  /**
     * @property {Deft.promise.Promise}
     * Promise of the future value of this Consequence.
  */

  promise: null,
  /**
     * @private
     * @property {Deft.promise.Resolver}
     * Internal Resolver for this Consequence.
  */

  resolver: null,
  /**
     * @private
     * @property {Function}
     Callback to execute when this Consequence is triggered with a fulfillment value.
  */

  onFulfilled: null,
  /**
     * @private
     * @property {Function}
     Callback to execute when this Consequence is triggered with a rejection reason.
  */

  onRejected: null,
  /**
     * @private
     * @property {Function}
     Callback to execute when this Consequence is updated with a progress value.
  */

  onProgress: null,
  /**
  	* @param {Function} onFulfilled Callback to execute to transform a fulfillment value.
  	* @param {Function} onRejected Callback to execute to transform a rejection reason.
  */

  constructor: function(onFulfilled, onRejected, onProgress) {
    this.onFulfilled = onFulfilled;
    this.onRejected = onRejected;
    this.onProgress = onProgress;
    this.resolver = Ext.create('Deft.promise.Resolver');
    this.promise = this.resolver.promise;
    return this;
  },
  /**
     * Trigger this Consequence with the specified action and value.
  	*
  	* @param {String} action Completion action (i.e. fulfill or reject).
  	* @param {Mixed} value Fulfillment value or rejection reason.
  */

  trigger: function(action, value) {
    switch (action) {
      case 'fulfill':
        this.propagate(value, this.onFulfilled, this.resolver, this.resolver.resolve);
        break;
      case 'reject':
        this.propagate(value, this.onRejected, this.resolver, this.resolver.reject);
    }
  },
  /**
  	* Update this Consequence with the specified progress value.
  	*
  	* @param {Mixed} value Progress value.
  */

  update: function(progress) {
    if (Deft.isFunction(this.onProgress)) {
      progress = this.onProgress(progress);
    }
    this.resolver.update(progress);
  },
  /**
  	* @private
  	* Transform and propagate the specified value using the
     * optional callback and propagate the transformed result.
  	*
  	* @param {Mixed} value Value to transform and/or propagate.
  	* @param {Function} callback (Optional) callback to use to transform the value.
  	* @param {Function} resolver Resolver to use to propagate the value, if no callback was specified.
  	* @param {Function} resolverMethod Resolver method to call to propagate the value, if no callback was specified.
  */

  propagate: function(value, callback, resolver, resolverMethod) {
    if (Deft.isFunction(callback)) {
      this.schedule(function() {
        var error;
        try {
          resolver.resolve(callback(value));
        } catch (_error) {
          error = _error;
          resolver.reject(error);
        }
      });
    } else {
      resolverMethod.call(this.resolver, value);
    }
  },
  /**
  	* @private
  	* @method
  	* Schedules the specified callback function to be executed on
     * the next turn of the event loop.
  	*
  	* @param {Function} callback Callback function.
     * @param {Mixed[]} parameters Optional callback parameters.
  	* @param {Object} scope Optional scope for the callback.
  */

  schedule: Ext.emptyFn
}, function() {
  var CallbackQueue, callbackQueue, nextTick;
  nextTick = typeof setImmediate !== "undefined" && setImmediate !== null ? setImmediate : function(task) {
    return setTimeout(task, 0);
  };
  CallbackQueue = (function() {
    function CallbackQueue() {
      var execute, queuedCallbackCount, queuedCallbacks;
      queuedCallbacks = new Array(1e4);
      queuedCallbackCount = 0;
      execute = function() {
        var index;
        index = 0;
        while (index < queuedCallbackCount) {
          queuedCallbacks[index]();
          queuedCallbacks[index] = null;
          index++;
        }
        queuedCallbackCount = 0;
      };
      this.schedule = function(callback) {
        queuedCallbacks[queuedCallbackCount++] = callback;
        if (queuedCallbackCount === 1) {
          nextTick(execute);
        }
      };
    }

    return CallbackQueue;

  })();
  callbackQueue = new CallbackQueue();
  this.prototype.schedule = function(callback, parameters, scope) {
    callbackQueue.schedule(callback, parameters, scope);
  };
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2014 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* @private
* Resolvers are used internally by Deferreds to create, resolve and reject
* Promises, and to propagate fulfillment and rejection.
*
* Developers never directly interact with a Resolver.
*
* Each Deferred has an associated Resolver, and each Resolver has an
* associated Promise. A Deferred delegates resolve() and reject() calls to
* its Resolver's resolve() and reject() methods. A Promise delegates
* then() calls to its Resolver's then() method. In this way, access to
* Resolver operations are divided between producer (Deferred) and consumer
* (Promise) roles.
*
* When a Resolver's resolve() method is called, it fulfills with the
* optionally specified value. If resolve() is called with a then-able
* (i.e.a Function or Object with a then() function, such as another
* Promise) it assimilates the then-able's result; the Resolver provides
* its own resolve() and reject() methods as the onFulfilled or onRejected
* arguments in a call to that then-able's then() function. If an error is
* thrown while calling the then-able's then() function (prior to any call
* back to the specified resolve() or reject() methods), the Resolver
* rejects with that error. If a Resolver's resolve() method is called with
* its own Promise, it rejects with a TypeError.
*
* When a Resolver's reject() method is called, it rejects with the
* optionally specified reason.
*
* Each time a Resolver's then() method is called, it captures a pair of
* optional onFulfilled and onRejected callbacks and returns a Promise of
* the Resolver's future value as transformed by those callbacks.
*/

Ext.define('Deft.promise.Resolver', {
  alternateClassName: ['Deft.Resolver'],
  requires: ['Deft.promise.Consequence'],
  /**
  	* @property {Deft.promise.Promise}
  	* Promise of the future value of this Deferred.
  */

  promise: null,
  /**
     * @private
  	* @property {Deft.promise.Consequence[]}
  	* Pending Consequences chained to this Resolver.
  */

  consequences: [],
  /**
     * @private
  	* @property {Boolean}
     * Indicates whether this Resolver has been completed.
  */

  completed: false,
  /**
     * @private
  	* @property {String}
     * The completion action (i.e. 'fulfill' or 'reject').
  */

  completionAction: null,
  /**
     * @private
  	* @property {Mixed}
     * The completion value (i.e. resolution value or rejection error).
  */

  completionValue: null,
  constructor: function() {
    this.promise = Ext.create('Deft.promise.Promise', this);
    this.consequences = [];
    this.completed = false;
    this.completionAction = null;
    this.completionValue = null;
    return this;
  },
  /**
  	* Used to specify onFulfilled and onRejected callbacks that will be
  	* notified when the future value becomes available.
  	*
  	* Those callbacks can subsequently transform the value that was
  	* fulfilled or the error that was rejected. Each call to then()
  	* returns a new Promise of that transformed value; i.e., a Promise
  	* that is fulfilled with the callback return value or rejected with
  	* any error thrown by the callback.
  	*
  	* @param {Function} onFulfilled (Optional) callback to execute to transform a fulfillment value.
  	* @param {Function} onRejected (Optional) callback to execute to transform a rejection reason.
  	* @param {Function} onProgress (Optional) callback to execute to transform a progress value.
  	*
  	* @return Promise that is fulfilled with the callback return value or rejected with any error thrown by the callback.
  */

  then: function(onFulfilled, onRejected, onProgress) {
    var consequence;
    consequence = Ext.create('Deft.promise.Consequence', onFulfilled, onRejected, onProgress);
    if (this.completed) {
      consequence.trigger(this.completionAction, this.completionValue);
    } else {
      this.consequences.push(consequence);
    }
    return consequence.promise;
  },
  /**
  	* Resolve this Resolver with the (optional) specified value.
  	*
  	* If called with a then-able (i.e.a Function or Object with a then()
  	* function, such as another Promise) it assimilates the then-able's
  	* result; the Resolver provides its own resolve() and reject() methods
  	* as the onFulfilled or onRejected arguments in a call to that
  	* then-able's then() function.  If an error is  thrown while calling
  	* the then-able's then() function (prior to any call back to the
  	* specified resolve() or reject() methods), the Resolver rejects with
  	* that error. If a Resolver's resolve() method is called with its own
  	* Promise, it rejects with a TypeError.
  	*
  	* Once a Resolver has been fulfilled or rejected, it is considered to be complete
  	* and subsequent calls to resolve() or reject() are ignored.
  	*
  	* @param {Mixed} value Value to resolve as either a fulfillment value or rejection reason.
  */

  resolve: function(value) {
    var error, isHandled, self, thenFn;
    if (this.completed) {
      return;
    }
    try {
      if (value === this.promise) {
        throw new TypeError('A Promise cannot be resolved with itself.');
      }
      if ((Ext.isObject(value) || Deft.isFunction(value)) && Deft.isFunction(thenFn = value.then)) {
        isHandled = false;
        try {
          self = this;
          thenFn.call(value, function(value) {
            if (!isHandled) {
              isHandled = true;
              self.resolve(value);
            }
          }, function(error) {
            if (!isHandled) {
              isHandled = true;
              self.reject(error);
            }
          });
        } catch (_error) {
          error = _error;
          if (!isHandled) {
            this.reject(error);
          }
        }
      } else {
        this.complete('fulfill', value);
      }
    } catch (_error) {
      error = _error;
      this.reject(error);
    }
  },
  /**
  	* Reject this Resolver with the specified reason.
  	*
  	* Once a Resolver has been rejected, it is considered to be complete
  	* and subsequent calls to resolve() or reject() are ignored.
  	*
  	* @param {Error} reason Rejection reason.
  */

  reject: function(reason) {
    if (this.completed) {
      return;
    }
    this.complete('reject', reason);
  },
  /**
  	* Updates progress for this Resolver, if it is still pending, triggering it to execute the 'onProgress' callback and propagate the resulting transformed progress value to Resolvers that originate from this Resolver.
  	*
  	* @param {Mixed} progress The progress value.
  */

  update: function(progress) {
    var consequence, _i, _len, _ref;
    if (this.completed) {
      return;
    }
    _ref = this.consequences;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      consequence = _ref[_i];
      consequence.update(progress);
    }
  },
  /**
     * @private
  	* Complete this Resolver with the specified action and value.
  	*
  	* @param {String} action Completion action (i.e. 'fufill' or 'reject').
  	* @param {Mixed} value Fulfillment value or rejection reason.
  */

  complete: function(action, value) {
    var consequence, _i, _len, _ref;
    this.completionAction = action;
    this.completionValue = value;
    this.completed = true;
    _ref = this.consequences;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      consequence = _ref[_i];
      consequence.trigger(this.completionAction, this.completionValue);
    }
    this.consequences = null;
  }
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2014 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* A Deferred is typically used within the body of a function that performs
* an asynchronous operation. When that operation succeeds, the Deferred
* should be resolved; if that operation fails, the Deferred should be rejected.
*
* Deferreds are the mechanism used to create new Promises. A Deferred has a
* single associated Promise that can be safely returned to external consumers
* to ensure they do not interfere with the resolution or rejection of the
* deferred operation.
*/

Ext.define('Deft.promise.Deferred', {
  alternateClassName: ['Deft.Deferred'],
  requires: ['Deft.promise.Resolver'],
  statics: {
    /**
    		* Convenience method that returns a Promise resolved with the specified value.
    		*
       	* @param {Mixed} value Value to resolve as either a fulfillment value or rejection reason.
    		* @return {Deft.promise.Promise} Resolved Promise.
    */

    resolve: function(value) {
      var deferred;
      deferred = Ext.create('Deft.promise.Deferred');
      deferred.resolve(value);
      return deferred.promise;
    },
    /**
    		* Convenience method that returns a new Promise rejected with the specified reason.
    		*
    		* @param {Error} reason Rejection reason.
    		* @return {Deft.promise.Promise} Rejected Promise.
    */

    reject: function(reason) {
      var deferred;
      deferred = Ext.create('Deft.promise.Deferred');
      deferred.reject(reason);
      return deferred.promise;
    }
  },
  /**
  	* @property {Deft.promise.Promise}
  	* Promise of the future value of this Deferred.
  */

  promise: null,
  /**
  	* @private
  	* @property {Deft.promise.Resolver}
  	* Internal Resolver for this Deferred.
  */

  resolver: null,
  constructor: function() {
    this.resolver = Ext.create('Deft.promise.Resolver');
    this.promise = this.resolver.promise;
    return this;
  },
  /**
  	* Resolve this Deferred with the specified value.
  	*
  	* Once a Deferred has been fulfilled or rejected, it is considered to be complete
  	* and subsequent calls to resolve() or reject() are ignored.
  	*
  	* @param {Mixed} value Value to resolve as either a fulfillment value or rejection reason.
  */

  resolve: function(value) {
    this.resolver.resolve(value);
  },
  /**
  	* Reject this Deferred with the specified error.
  	*
  	* Once a Deferred has been rejected, it is considered to be complete
  	* and subsequent calls to resolve() or reject() are ignored.
  	*
  	* @param {Error} reason Rejection reason.
  */

  reject: function(reason) {
    this.resolver.reject(reason);
  },
  /**
  	* Update progress for this Deferred, if it is still pending.
  	*
  	* @param {Mixed} progress Progress value.
  */

  update: function(progress) {
    this.resolver.update(progress);
  },
  /**
  	* Return the Promise of the future value of this Deferred.
  	*
  	* @return {Deft.promise.Promise} Promise of the future value.
  */

  getPromise: function() {
    return this.promise;
  }
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2014 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).

Promise.when(), all(), any(), some(), map(), reduce(), delay() and timeout()
methods adapted from: [when.js](https://github.com/cujojs/when)
Copyright (c) B Cavalier & J Hann
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
Promises represent a future value; i.e., a value that may not yet be available.

A Promise's then() method is used to specify onFulfilled and onRejected
callbacks that will be notified when the future value becomes available. Those
callbacks can subsequently transform the value that was resolved or the reason
that was rejected. Each call to then() returns a new Promise of that
transformed value; i.e., a Promise that is resolved with the callback return
value or rejected with any error thrown by the callback.

## <u>[Basic Usage](https://github.com/deftjs/DeftJS/wiki/Promises%20API)</u>

In it's most basic and common form, a method will create and return a Promise like this:

    // A method in a service class which uses a Store and returns a Promise
    loadCompanies: function() {
      var deferred = Ext.create('Deft.Deferred');

      this.companyStore.load({

        callback: function(records, operation, success) {
          if (success) {
            deferred.resolve(records);
          } else {
            deferred.reject("Error loading Companies.");
          }
        }

      });

      return deferred.promise;
    }

You can see this method first creates a Deferred object. It then returns a Promise object for
use by the caller. Finally, in the asynchronous callback, it resolves the Deferred object if
the call was successful, and rejects the Deferred if the call failed.

The method which calls the above code and works with the returned Promise might look like:

    // Using a Promise returned by another object.
    loadCompanies: function() {

      this.companyService.loadCompanies().then({
        success: function(records) {
          // Do something with result.
        },
        failure: function(error) {
          // Do something on failure.
        }
      }).always(function() {
        // Do something whether call succeeded or failed
      });

    }

The calling code uses the Promise returned from the companyService.loadCompanies() method and
uses then() to attach success and failure handlers. Finally, an always() method call is chained
onto the returned Promise. This specifies a callback function that will run whether the underlying
call succeeded or failed.
*/

Ext.define('Deft.promise.Promise', {
  alternateClassName: ['Deft.Promise'],
  requires: ['Deft.promise.Deferred', 'Deft.util.Function'],
  statics: {
    /**
    		* Returns a new Promise that:
    		*
    		* * resolves immediately for the specified value, or
    		* * resolves or rejects when the specified {@link Deft.promise.Promise Promise} (or third-party Promise or then()-able) is resolved or rejected.
    		*
    		* @param {Mixed} promiseOrValue A Promise (or third-party Promise or then()-able) or value.
    		* @return {Deft.promise.Promise} A Promise of the specified Promise or value.
    */

    when: function(promiseOrValue) {
      var deferred;
      deferred = Ext.create('Deft.promise.Deferred');
      deferred.resolve(promiseOrValue);
      return deferred.promise;
    },
    /**
    		* Determines whether the specified value is a Promise (including third-party untrusted Promises or then()-ables), based on the Promises/A specification feature test.
    		* 
    		* @param {Mixed} value A potential Promise.
    		* @return {Boolean} A Boolean indicating whether the specified value was a Promise.
    */

    isPromise: function(value) {
      return (Ext.isObject(value) || Deft.isFunction(value)) && Deft.isFunction(value.then);
    },
    /**
    		* Returns a new Promise that will only resolve once all the specified `promisesOrValues` have resolved.
    		* 
    		* The resolution value will be an Array containing the resolution value of each of the `promisesOrValues`.
    		*
    		* @param {Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise} promisesOrValues An Array of values or Promises, or a Promise of an Array of values or Promises.
    		* @return {Deft.promise.Promise} A Promise of an Array of the resolved values.
    */

    all: function(promisesOrValues) {
      if (!(Ext.isArray(promisesOrValues) || Deft.Promise.isPromise(promisesOrValues))) {
        throw new Error('Invalid parameter: expected an Array or Promise of an Array.');
      }
      return Deft.Promise.when(promisesOrValues).then(function(promisesOrValues) {
        var deferred, index, promiseOrValue, remainingToResolve, resolve, results, _i, _len;
        remainingToResolve = promisesOrValues.length;
        results = new Array(promisesOrValues.length);
        deferred = Ext.create('Deft.promise.Deferred');
        if (!remainingToResolve) {
          deferred.resolve(results);
        } else {
          resolve = function(item, index) {
            return Deft.Promise.when(item).then(function(value) {
              results[index] = value;
              if (!--remainingToResolve) {
                deferred.resolve(results);
              }
              return value;
            }, function(reason) {
              return deferred.reject(reason);
            });
          };
          for (index = _i = 0, _len = promisesOrValues.length; _i < _len; index = ++_i) {
            promiseOrValue = promisesOrValues[index];
            if (index in promisesOrValues) {
              resolve(promiseOrValue, index);
            } else {
              remainingToResolve--;
            }
          }
        }
        return deferred.promise;
      });
    },
    /**
    		* Initiates a competitive race, returning a new Promise that will resolve when any one of the specified `promisesOrValues` have resolved, or will reject when all `promisesOrValues` have rejected or cancelled.
    		* 
    		* The resolution value will the first value of `promisesOrValues` to resolve.
    		*
    		* @param {Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise} promisesOrValues An Array of values or Promises, or a Promise of an Array of values or Promises.
    		* @return {Deft.promise.Promise} A Promise of the first resolved value.
    */

    any: function(promisesOrValues) {
      if (!(Ext.isArray(promisesOrValues) || Deft.Promise.isPromise(promisesOrValues))) {
        throw new Error('Invalid parameter: expected an Array or Promise of an Array.');
      }
      return Deft.Promise.some(promisesOrValues, 1).then(function(array) {
        return array[0];
      }, function(error) {
        if (error instanceof Error && error.message === 'Too few Promises were resolved.') {
          throw new Error('No Promises were resolved.');
        } else {
          throw error;
        }
      });
    },
    /**
    		* Initiates a competitive race, returning a new Promise that will resolve when `howMany` of the specified `promisesOrValues` have resolved, or will reject when it becomes impossible for `howMany` to resolve.
    		* 
    		* The resolution value will be an Array of the first `howMany` values of `promisesOrValues` to resolve.
    		*
    		* @param {Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise} promisesOrValues An Array of values or Promises, or a Promise of an Array of values or Promises.
    		* @param {Number} howMany The expected number of resolved values.
    		* @return {Deft.promise.Promise} A Promise of the expected number of resolved values.
    */

    some: function(promisesOrValues, howMany) {
      if (!(Ext.isArray(promisesOrValues) || Deft.Promise.isPromise(promisesOrValues))) {
        throw new Error('Invalid parameter: expected an Array or Promise of an Array.');
      }
      if (!Ext.isNumeric(howMany) || howMany <= 0) {
        throw new Error('Invalid parameter: expected a positive integer.');
      }
      return Deft.Promise.when(promisesOrValues).then(function(promisesOrValues) {
        var deferred, index, onReject, onResolve, promiseOrValue, remainingToReject, remainingToResolve, values, _i, _len;
        values = [];
        remainingToResolve = howMany;
        remainingToReject = (promisesOrValues.length - remainingToResolve) + 1;
        deferred = Ext.create('Deft.promise.Deferred');
        if (promisesOrValues.length < howMany) {
          deferred.reject(new Error('Too few Promises were resolved.'));
        } else {
          onResolve = function(value) {
            if (remainingToResolve > 0) {
              values.push(value);
            }
            remainingToResolve--;
            if (remainingToResolve === 0) {
              deferred.resolve(values);
            }
            return value;
          };
          onReject = function(reason) {
            remainingToReject--;
            if (remainingToReject === 0) {
              deferred.reject(new Error('Too few Promises were resolved.'));
            }
            return reason;
          };
          for (index = _i = 0, _len = promisesOrValues.length; _i < _len; index = ++_i) {
            promiseOrValue = promisesOrValues[index];
            if (index in promisesOrValues) {
              Deft.Promise.when(promiseOrValue).then(onResolve, onReject);
            }
          }
        }
        return deferred.promise;
      });
    },
    /**
    		* Returns a new Promise that will automatically resolve with the specified Promise or value after the specified delay (in milliseconds).
    		*
    		* @param {Mixed} promiseOrValue A Promise or value.
    		* @param {Number} milliseconds A delay duration (in milliseconds).
    		* @return {Deft.promise.Promise} A Promise of the specified Promise or value that will resolve after the specified delay.
    */

    delay: function(promiseOrValue, milliseconds) {
      var deferred;
      if (arguments.length === 1) {
        milliseconds = promiseOrValue;
        promiseOrValue = void 0;
      }
      milliseconds = Math.max(milliseconds, 0);
      deferred = Ext.create('Deft.promise.Deferred');
      setTimeout(function() {
        deferred.resolve(promiseOrValue);
      }, milliseconds);
      return deferred.promise;
    },
    /**
    		* Returns a new Promise that will automatically reject after the specified timeout (in milliseconds) if the specified promise has not resolved or rejected.
    		*
    		* @param {Mixed} promiseOrValue A Promise or value.
    		* @param {Number} milliseconds A timeout duration (in milliseconds).
    		* @return {Deft.promise.Promise} A Promise of the specified Promise or value that enforces the specified timeout.
    */

    timeout: function(promiseOrValue, milliseconds) {
      var cancelTimeout, deferred, timeoutId;
      deferred = Ext.create('Deft.promise.Deferred');
      timeoutId = setTimeout(function() {
        if (timeoutId) {
          deferred.reject(new Error('Promise timed out.'));
        }
      }, milliseconds);
      cancelTimeout = function() {
        clearTimeout(timeoutId);
        return timeoutId = null;
      };
      Deft.Promise.when(promiseOrValue).then(function(value) {
        cancelTimeout();
        deferred.resolve(value);
      }, function(reason) {
        cancelTimeout();
        deferred.reject(reason);
      });
      return deferred.promise;
    },
    /**
    		* Returns a new function that wraps the specified function and caches the results for previously processed inputs.
    		* 
    		* Similar to {@link Deft.Function#memoize Deft.util.Function::memoize()}, except it allows for parameters that are Promises and/or values.
    		*
    		* @param {Function} fn A Function to wrap.
    		* @param {Object} scope An optional scope in which to execute the wrapped function.
    		* @param {Function} hashFn An optional function used to compute a hash key for storing the result, based on the arguments to the original function.
    		* @return {Function} The new wrapper function.
    */

    memoize: function(fn, scope, hashFn) {
      var memoizedFn;
      memoizedFn = Deft.util.Function.memoize(fn, scope, hashFn);
      return function() {
        return Deft.Promise.all(Ext.Array.toArray(arguments)).then(function(values) {
          return memoizedFn.apply(scope, values);
        });
      };
    },
    /**
    		* Traditional map function, similar to `Array.prototype.map()`, that allows input to contain promises and/or values.
    		* 
    		* The specified map function may return either a value or a promise.
    		*
    		* @param {Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise} promisesOrValues An Array of values or Promises, or a Promise of an Array of values or Promises.
    		* @param {Function} mapFn A Function to call to transform each resolved value in the Array.
    		* @return {Deft.promise.Promise} A Promise of an Array of the mapped resolved values.
    */

    map: function(promisesOrValues, mapFn) {
      if (!(Ext.isArray(promisesOrValues) || Deft.Promise.isPromise(promisesOrValues))) {
        throw new Error('Invalid parameter: expected an Array or Promise of an Array.');
      }
      if (!Deft.isFunction(mapFn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      return Deft.Promise.when(promisesOrValues).then(function(promisesOrValues) {
        var deferred, index, promiseOrValue, remainingToResolve, resolve, results, _i, _len;
        remainingToResolve = promisesOrValues.length;
        results = new Array(promisesOrValues.length);
        deferred = Ext.create('Deft.promise.Deferred');
        if (!remainingToResolve) {
          deferred.resolve(results);
        } else {
          resolve = function(item, index) {
            return Deft.Promise.when(item).then(function(value) {
              return mapFn(value, index, results);
            }).then(function(value) {
              results[index] = value;
              if (!--remainingToResolve) {
                deferred.resolve(results);
              }
              return value;
            }, function(reason) {
              return deferred.reject(reason);
            });
          };
          for (index = _i = 0, _len = promisesOrValues.length; _i < _len; index = ++_i) {
            promiseOrValue = promisesOrValues[index];
            if (index in promisesOrValues) {
              resolve(promiseOrValue, index);
            } else {
              remainingToResolve--;
            }
          }
        }
        return deferred.promise;
      });
    },
    /**
    		* Traditional reduce function, similar to `Array.reduce()`, that allows input to contain promises and/or values.
    		*
    		* @param {Mixed[]/Deft.promise.Promise[]/Deft.promise.Promise} promisesOrValues An Array of values or Promises, or a Promise of an Array of values or Promises.
    		* @param {Function} reduceFn A Function to call to transform each successive item in the Array into the final reduced value.
    		* @param {Mixed} initialValue An initial Promise or value.
    		* @return {Deft.promise.Promise} A Promise of the reduced value.
    */

    reduce: function(promisesOrValues, reduceFn, initialValue) {
      var initialValueSpecified;
      if (!(Ext.isArray(promisesOrValues) || Deft.Promise.isPromise(promisesOrValues))) {
        throw new Error('Invalid parameter: expected an Array or Promise of an Array.');
      }
      if (!Deft.isFunction(reduceFn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      initialValueSpecified = arguments.length === 3;
      return Deft.Promise.when(promisesOrValues).then(function(promisesOrValues) {
        var reduceArguments;
        reduceArguments = [
          function(previousValueOrPromise, currentValueOrPromise, currentIndex) {
            return Deft.Promise.when(previousValueOrPromise).then(function(previousValue) {
              return Deft.Promise.when(currentValueOrPromise).then(function(currentValue) {
                return reduceFn(previousValue, currentValue, currentIndex, promisesOrValues);
              });
            });
          }
        ];
        if (initialValueSpecified) {
          reduceArguments.push(initialValue);
        }
        return Deft.Promise.reduceArray.apply(promisesOrValues, reduceArguments);
      });
    },
    /**
    		* Fallback implementation when Array.reduce is not available.
    		* @private
    */

    reduceArray: function(reduceFn, initialValue) {
      var args, array, index, length, reduced;
      index = 0;
      array = Object(this);
      length = array.length >>> 0;
      args = arguments;
      if (args.length <= 1) {
        while (true) {
          if (index in array) {
            reduced = array[index++];
            break;
          }
          if (++index >= length) {
            throw new TypeError('Reduce of empty array with no initial value');
          }
        }
      } else {
        reduced = args[1];
      }
      while (index < length) {
        if (index in array) {
          reduced = reduceFn(reduced, array[index], index, array);
        }
        index++;
      }
      return reduced;
    },
    /**
    		* @private
    		* Rethrows the specified Error on the next turn of the event loop.
    */

    rethrowError: function(error) {
      Deft.util.Function.nextTick(function() {
        throw error;
      });
    }
  },
  /**
  	* @private
  	* @property {Deft.promise.Resolver}
  	* Internal Resolver for this Promise.
  */

  resolver: null,
  /**
  	* @private
  	* NOTE: {@link Deft.promise.Deferred Deferreds} are the mechanism used to create new Promises.
  	* @param {Deft.promise.Resolver} onRejected Callback to execute to transform a rejection reason.
  */

  constructor: function(resolver) {
    this.resolver = resolver;
    return this;
  },
  /**
     * Attaches onFulfilled and onRejected callbacks that will be
  	* notified when the future value becomes available.
  	*
  	* Those callbacks can subsequently transform the value that was
  	* fulfilled or the error that was rejected. Each call to then()
  	* returns a new Promise of that transformed value; i.e., a Promise
  	* that is fulfilled with the callback return value or rejected with
  	* any error thrown by the callback.
  	*
  	* @param {Function} onFulfilled Optional callback to execute to transform a fulfillment value.
  	* @param {Function} onRejected Optional callback to execute to transform a rejection reason.
  	* @param {Function} onProgress Optional callback function to be called with progress updates.
  	* @param {Object} scope Optional scope for the callback(s).
  	*
  	* @return {Deft.promise.Promise} Promise that is fulfilled with the callback return value or rejected with any error thrown by the callback.
  */

  then: function(onFulfilled, onRejected, onProgress, scope) {
    var _ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      _ref = arguments[0], onFulfilled = _ref.success, onRejected = _ref.failure, onProgress = _ref.progress, scope = _ref.scope;
    }
    if (scope != null) {
      if (Deft.isFunction(onFulfilled)) {
        onFulfilled = Ext.Function.bind(onFulfilled, scope);
      }
      if (Deft.isFunction(onRejected)) {
        onRejected = Ext.Function.bind(onRejected, scope);
      }
      if (Deft.isFunction(onProgress)) {
        onProgress = Ext.Function.bind(onProgress, scope);
      }
    }
    return this.resolver.then(onFulfilled, onRejected, onProgress);
  },
  /**
  	* Attaches an onRejected callback that will be notified if this
  	* Promise is rejected.
  	*
  	* The callback can subsequently transform the reason that was
  	* rejected. Each call to otherwise() returns a new Promise of that
  	* transformed value; i.e., a Promise that is resolved with the
  	* original resolved value, or resolved with the callback return value
  	* or rejected with any error thrown by the callback.
  	*
  	* @param {Function} onRejected Callback to execute to transform a rejection reason.
  	* @param {Object} scope Optional scope for the callback.
  	*
  	* @return {Deft.promise.Promise} Promise of the transformed future value.
  */

  otherwise: function(onRejected, scope) {
    var _ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      _ref = arguments[0], onRejected = _ref.fn, scope = _ref.scope;
    }
    if (scope != null) {
      onRejected = Ext.Function.bind(onRejected, scope);
    }
    return this.resolver.then(null, onRejected);
  },
  /**
  	* Attaches an onCompleted callback that will be notified when this
  	* Promise is completed.
  	*
  	* Similar to "finally" in "try..catch..finally".
  	*
  	* NOTE: The specified callback does not affect the resulting Promise's
  	* outcome; any return value is ignored and any Error is rethrown.
  	*
  	* @param {Function} onCompleted Callback to execute when the Promise is resolved or rejected.
  	* @param {Object} scope Optional scope for the callback.
  	*
  	* @return {Deft.promise.Promise} A new "pass-through" Promise that is resolved with the original value or rejected with the original reason.
  */

  always: function(onCompleted, scope) {
    var _ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      _ref = arguments[0], onCompleted = _ref.fn, scope = _ref.scope;
    }
    if (scope != null) {
      onCompleted = Ext.Function.bind(onCompleted, scope);
    }
    return this.resolver.then(function(value) {
      var error;
      try {
        onCompleted();
      } catch (_error) {
        error = _error;
        Deft.promise.Promise.rethrowError(error);
      }
      return value;
    }, function(reason) {
      var error;
      try {
        onCompleted();
      } catch (_error) {
        error = _error;
        Deft.promise.Promise.rethrowError(error);
      }
      throw reason;
    });
  },
  /**
  	* Terminates a Promise chain, ensuring that unhandled rejections will
  	* be rethrown as Errors.
  	*
  	* One of the pitfalls of interacting with Promise-based APIs is the
  	* tendency for important errors to be silently swallowed unless an
  	* explicit rejection handler is specified.
  	*
  	* For example:
  	*
  	*     promise
  	*         .then( function () {
  	*             // logic in your callback throws an error and it is interpreted as a rejection.
  	*             throw new Error("Boom!");
  	*         });
  	*     // The Error was not handled by the Promise chain and is silently swallowed.
  	*
  	* This problem can be addressed by terminating the Promise chain with the done() method:
  	*
  	*     promise
  	*         .then( function () {
  	*             // logic in your callback throws an error and it is interpreted as a rejection.
  	*             throw new Error("Boom!");
  	*         })
  	*         .done();
  	*     // The Error was not handled by the Promise chain and is rethrown by done() on the next tick.
  	*
  	* The done() method ensures that any unhandled rejections are rethrown
  	* as Errors.
  */

  done: function() {
    this.resolver.then(null, Deft.promise.Promise.rethrowError);
  },
  /**
  	* Cancels this Promise if it is still pending, triggering a rejection
  	* with a CancellationError that will propagate to any Promises
  	* originating from this Promise.
  	*
  	* NOTE: Cancellation only propagates to Promises that branch from the
  	* target Promise. It does not traverse back up to parent branches, as
  	* this would reject nodes from which other Promises may have branched,
  	* causing unintended side-effects.
  	*
  	* @param {Error} reason Cancellation reason.
  */

  cancel: function(reason) {
    if (reason == null) {
      reason = null;
    }
    this.resolver.reject(new CancellationError(reason));
  },
  /**
  	* Logs the resolution or rejection of this Promise with the specified
  	* category and optional identifier. Messages are logged via all
  	* registered custom logger functions.
  	*
  	* @param {String} identifier An optional identifier to incorporate into the resulting log entry.
  	*
  	* @return {Deft.promise.Promise} A new "pass-through" Promise that is resolved with the original value or rejected with the original reason.
  */

  log: function(identifier) {
    if (identifier == null) {
      identifier = '';
    }
    return this.resolver.then(function(value) {
      Deft.Logger.log("" + (identifier || 'Promise') + " resolved with value: " + value);
      return value;
    }, function(reason) {
      Deft.Logger.log("" + (identifier || 'Promise') + " rejected with reason: " + reason);
      throw reason;
    });
  }
}, function() {
  var target;
  if (Array.prototype.reduce != null) {
    this.reduceArray = Array.prototype.reduce;
  }
  target = typeof exports !== "undefined" && exports !== null ? exports : window;
  target.CancellationError = function(reason) {
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CancellationError);
    }
    this.name = 'Canceled';
    this.message = reason;
  };
  target.CancellationError.prototype = new Error();
  target.CancellationError.constructor = target.CancellationError;
});

// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).

sequence(), parallel(), pipeline() methods adapted from:
[when.js](https://github.com/cujojs/when)
Copyright (c) B Cavalier & J Hann
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* A collection of useful static methods for chaining execution of an Array of Functions using {@link Deft.promise.Promise Promises}.
*/

Ext.define('Deft.promise.Chain', {
  alternateClassName: ['Deft.Chain'],
  requires: ['Deft.promise.Promise', 'Deft.util.Function'],
  statics: {
    /**
    		* Execute an Array (or {@link Deft.promise.Promise Promise} of an Array) of functions sequentially.
    		* 
    		* The specified functions may optionally return their results as {@link Deft.promise.Promise Promises}.
    		*
    		* @param {Function[]/Deft.promise.Promise} fns The Array (or Promise of an Array) of functions to execute.
    		* @param {Object} scope Optional scope in which to execute the specified functions.
    		* @return {Deft.promise.Promise} Promise of an Array of results for each function call  (in the same order).
    */

    sequence: function(fns, scope) {
      var args;
      if (scope == null) {
        scope = null;
      }
      args = [].slice.call(arguments, 2);
      return Deft.Promise.reduce(fns, function(results, fn) {
        if (!Deft.isFunction(fn)) {
          throw new Error('Invalid parameter: expected a function.');
        }
        return Deft.Promise.when(fn.apply(scope, args)).then(function(result) {
          results.push(result);
          return results;
        });
      }, []);
    },
    /**
    		* Execute an Array (or {@link Deft.promise.Promise Promise} of an Array) of functions in parallel.
    		* 
    		* The specified functions may optionally return their results as {@link Deft.promise.Promise Promises}.
    		*
    		* @param {Function[]/Deft.promise.Promise} fns The Array (or Promise of an Array) of functions to execute.
    		* @param {Object} scope Optional scope in which to execute the specified functions.
    		* @return {Deft.promise.Promise} Promise of an Array of results for each function call (in the same order).
    */

    parallel: function(fns, scope) {
      var args;
      if (scope == null) {
        scope = null;
      }
      args = [].slice.call(arguments, 2);
      return Deft.Promise.map(fns, function(fn) {
        if (!Ext.isFunction(fn)) {
          throw new Error('Invalid parameter: expected a function.');
        }
        return fn.apply(scope, args);
      });
    },
    /**
    		* Execute an Array (or {@link Deft.promise.Promise Promise} of an Array) of functions as a pipeline, where each function's result is passed to the subsequent function as input.
    		* 
    		* The specified functions may optionally return their results as {@link Deft.promise.Promise Promises}.
    		* 
    		* @param {Function[]/Deft.promise.Promise} fns The Array (or Promise of an Array) of functions to execute.
    		* @param {Object} initialValue Initial value to be passed to the first function in the pipeline.
    		* @param {Object} scope Optional scope in which to execute the specified functions.
    		* @return {Deft.promise.Promise} Promise of the result value for the final function in the pipeline.
    */

    pipeline: function(fns, initialValue, scope) {
      if (scope == null) {
        scope = null;
      }
      return Deft.Promise.reduce(fns, function(value, fn) {
        if (!Ext.isFunction(fn)) {
          throw new Error('Invalid parameter: expected a function.');
        }
        return fn.call(scope, value);
      }, initialValue);
    }
  }
});

